# 零、概念



## 1、 数据结构


| 数据结构 | 变种 | 相关题目 | 讲解文章 |
|:-------:|:-------|:------|:------|
|顺序线性表：向量||||
|单链表        |1. 双向链表<br>2. 静态链表<br>3. 对称矩阵<br>4. 稀疏矩阵|||
|哈希表        |1. 散列函数<br>2. 解决碰撞/填充因子<br>|||
|栈和队列       |1. 广义栈<br>2. 双端队列<br>|||
|队列         |1. 链表实现<br>2. 循环数组实现<br>3. 双端队列|||
|字符串        |1. KMP算法<br>2. 有限状态自动机<br>3. 模式匹配有限状态自动机<br>4. BM 模式匹配算法<br>5. BM-KMP 算法<br>6. BF 算法|||
|树          |1. 二叉树<br>2. 并查集<br>3. Huffman 树|||
|数组实现的堆  |1. 极大堆和极小堆<br>2. 极大极小堆<br>3. 双端堆<br>4. d 叉堆|||
|树实现的堆    |1. 左堆<br>2. 扁堆<br>3. 二项式堆<br>4. 斐波那契堆<br>5. 配对堆|||
|查找         |1. 哈希表<br>2. 跳跃表<br>3. 排序二叉树<br>4. AVL 树<br>5. B 树 / B+ 树 / B* 树<br>6. AA 树<br>7. 红黑树<br>8. 排序二叉堆<br>9. Splay 树<br>10. 双链树<br>11. Trie 树<br>12. R 树|||
|--------------------------------------------|--------------------------------------------------------------------------------------------|---------------------------|-----------------------------------|

## 2、 Algorithm


| 算法 | 具体类型 | 相关题目 | 讲解文章 |
|:-------:|:-------|:------|:------|
|排序算法|1. 冒泡排序<br>2. 插入排序<br>3. 选择排序<br>4. 希尔 Shell 排序<br>5. 快速排序<br>6. 归并排序<br>7. 堆排序<br>8. 线性排序算法<br>9. 自省排序<br>10. 间接排序<br>11. 计数排序<br>12. 基数排序<br>13. 桶排序<br>14. 外部排序 - k 路归并败者树<br>15. 外部排序 - 最佳归并树|||
|递归与分治||1. 二分搜索/查找<br>2. 大整数的乘法<br>3. Strassen 矩阵乘法<br>4. 棋盘覆盖<br>5. 合并排序<br>6. 快速排序<br>7. 线性时间选择<br>8. 最接近点对问题<br>9. 循环赛日程表<br>||
|动态规划||1. 矩阵连乘问题<br>2. 最长公共子序列<br>3. 最大子段和<br>4. 凸多边形最优三角剖分<br>5. 多边形游戏<br>6. 图像压缩<br>7. 电路布线<br>8. 流水作业调度<br>9. 0-1 背包问题/背包九讲<br>10. 最优二叉搜索树<br>11. 动态规划加速原理<br>12. 树型 DP<br>||
|贪心||1. 活动安排问题<br>2. 最优装载<br>3. 哈夫曼编码<br>4. 单源最短路径<br>5. 最小生成树<br>6. 多机调度问题<br>||
|回溯法||1. 装载问题<br>2. 批处理作业调度<br>3. 符号三角形问题<br>4. n 后问题<br>5. 0-1 背包问题<br>6. 最大团问题<br>7. 图的 m 着色问题<br>8. 旅行售货员问题<br>9. 圆排列问题<br>10. 电路板排列问题<br>11. 连续邮资问题<br>||
|搜索|1. 枚举<br>2. DFS<br>3. BFS<br>4. 启发式搜索<br>|||
|随机化|1. 随机数<br>2. 数值随机化算法<br>3. Sherwood 舍伍德算法<br>4. Las Vegas 拉斯维加斯算法<br>5. Monte Carlo 蒙特卡罗算法<br>|1. 计算 π 值<br>2. 计算定积分<br>3. 解非线性方程组<br>4. 线性时间选择算法<br>5. 跳跃表<br>6. n 后问题<br>7. 整数因子分解<br>8. 主元素问题<br>9. 素数测试<br>||
|图论|1. 遍历 DFS / BFS<br>2. AOV / AOE 网络<br>3. Kruskal 算法(最小生成树)<br>4. Prim 算法(最小生成树)<br>5. Boruvka 算法(最小生成树)<br>6. Dijkstra 算法(单源最短路径)<br>7. Bellman-Ford 算法(单源最短路径)<br>8. SPFA 算法(单源最短路径)<br>9. Floyd 算法(多源最短路径)<br>10. Johnson 算法(多源最短路径)<br>11. Fleury 算法(欧拉回路)<br>12. Ford-Fulkerson 算法(最大网络流增广路)<br>13. Edmonds-Karp 算法(最大网络流)<br>14. Dinic 算法(最大网络流)<br>15. 一般预流推进算法<br>16. 最高标号预流推进 HLPP 算法<br>17. Primal-Dual 原始对偶算法(最小费用流)18. Kosaraju 算法(有向图强连通分量)<br>19. Tarjan 算法(有向图强连通分量)<br>20. Gabow 算法(有向图强连通分量)<br>21. 匈牙利算法(二分图匹配)<br>22. Hopcroft－Karp 算法(二分图匹配)<br>23. kuhn munkras 算法(二分图最佳匹配)<br>24. Edmonds’ Blossom-Contraction 算法(一般图匹配)<br>|1. 图遍历<br>2. 有向图和无向图的强弱连通性<br>3. 割点/割边<br>3. AOV 网络和拓扑排序<br>4. AOE 网络和关键路径<br>5. 最小代价生成树/次小生成树<br>6. 最短路径问题/第 K 短路问题<br>7. 最大网络流问题<br>8. 最小费用流问题<br>9. 图着色问题<br>10. 差分约束系统<br>11. 欧拉回路<br>12. 中国邮递员问题<br>13. 汉密尔顿回路<br>14. 最佳边割集/最佳点割集/最小边割集/最小点割集/最小路径覆盖/最小点集覆盖 <br>15. 边覆盖集<br>16. 二分图完美匹配和最大匹配问题<br>17. 仙人掌图<br>18. 弦图<br>19. 稳定婚姻问题<br>20. 最大团问题<br>||
|数论||1. 最大公约数<br> 2. 最小公倍数<br>3. 分解质因数<br>4. 素数判定<br>5. 进制转换<br>6. 高精度计算<br>7. 整除问题<br>8. 同余问题<br>9. 欧拉函数<br>10. 扩展欧几里得<br>11. 置换群<br>12. 母函数<br>13. 离散变换<br>14. 康托展开<br>15. 矩阵<br>16. 向量<br>17. 线性方程组<br>18. 线性规划<br> ||
|几何||1. 凸包 - Gift wrapping<br>2. 凸包 - Graham scan<br>3. 线段问题<br> 4. 多边形和多面体相关问题<br>||
|NP 完全|1. 计算模型<br>2. P 类与 NP 类问题<br>3. NP 完全问题<br>4. NP 完全问题的近似算法<br>|1. 随机存取机 RAM<br>2. 随机存取存储程序机 RASP<br>3. 图灵机<br>4. 非确定性图灵机<br>5. P 类与 NP 类语言<br>6. 多项式时间验证<br>7. 多项式时间变换<br>8. Cook定理<br>9. 合取范式的可满足性问题 CNF-SAT<br>10. 3 元合取范式的可满足性问题 3-SAT<br>11. 团问题 CLIQUE<br>12. 顶点覆盖问题 VERTEX-COVER<br>13. 子集和问题 SUBSET-SUM<br>14. 哈密顿回路问题 HAM-CYCLE<br>15. 旅行售货员问题 TSP<br>16. 顶点覆盖问题的近似算法<br>17. 旅行售货员问题近似算法<br>18. 具有三角不等式性质的旅行售货员问题<br>19. 一般的旅行售货员问题<br>20. 集合覆盖问题的近似算法<br>21. 子集和问题的近似算法<br>22. 子集和问题的指数时间算法<br>23. 子集和问题的多项式时间近似格式<br>||
|------------|------------------------------------------------------------------|-----------------------------------------------------------------|--------------------|



# 一、数据结构
（1）线性数据结构：元素之间一般存在元素之间存在一对一关系，是最常用的一类数据结构，典型的有：数组、栈、队列和线性表
线性表：零个或多个数据元素的有限序列

不同的数据物理存储结构
- 顺序存储结构：数组
- 链式存储结构：链表
特殊类型（功能比较专一）：
- 栈（先入后出）：比如撤销功能
- 队列（先入先出） ：比如客服系统
（栈和队列底层是通过数组实现的）

（2）树形结构：结点间具有层次关系，每一层的一个结点能且只能和上一层的一个结点相关，但同时可以和下一层的多个结点相关，称为“一对多”关系，常见类型有：树、堆
（3）图形结构：在图形结构中，允许多个结点之间相关，称为“多对多”关系




## 一、数组

### 1、数组概念

在连续内存空间中，存储相同类型的元素。
数组索引从0开始计数，即索引n对应数组第n-1个元素

基本操作及其时间复杂度：

    访问（通过索引获取）：O(1)
    搜索（通过元素获取）：O(n)
    插入：O(n)
    删除：O(n)
    
    (访问是指根据索引查询，搜索是指根据指根据值查询)
    
- 优点：
    易查询
- 缺点：
    不易插入删除
    需要提前固定存储空间
- 应用场景：
    适用于变化少多查询的线性表

### 2、python中数组实现

### 3、基本操作python实现：
```python
#创建
array=[1,2,3,4]
#添加元素5
array.append(5)
#访问第2个元素
num=array[1]
#修改第2个元素为6
array[1]=6
#查找元素3对应的索引
idx=array.index(3)
#插入元素6到索引1
array.insert(1,6)
#删除索引1对应的元素
del array[1]
#删除元素3
array.remove(3)
#获取数组长度
length=len(array)
#遍历数组一：遍历元素
for i in array:
	num=i
#遍历数组二：遍历索引与元素
for idx,i in enumerate(array):
	index=idx
	num=i
#数组排序,参数reverse默认为False
array.sort()

```


## 二、栈

## 三、队列

## 四、链表

## 五、树

## 六、散列表

## 七、堆

## 八、图


# 二、算法（Algorithm）
## 一、排序

排序分类：

 - 内排序：在内存中进行（排序算法）
 - 外排序：在磁盘上进行


内部排序和外部排序：

    一类是整个排序过程在内存储器中进行，称为内部排序；
    另一类是由于待排序元素数量太大，以至于内存储器无法容纳全部数据，排序需要借助外部存储设备才能完成，这类排序称为外部排序。
    本章介绍的排序方法都属于内部排序

比较排序和非比较排序：

    大部分排序都是需要通过比较首先来判断大小，作为排序的依据的。
    但是也有例外的，比如计数排序、基数排序，不需要进行比较。效率可以做到更高，但是会有一些限制条件，也可能需要更多的空间。
    冒泡排序、选择排序、直接插入排序是最基本的三种排序，效率最低，但是算法简单。排序的学习一般从这三种排序算法开始。


 <img src="img\数据结构与算法\20190903082625702.png" alt="20190903082730350" style="zoom: 50%;" />


二、术语说明

    稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
    不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
    内排序：所有排序操作都在内存中完成；
    外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
    时间复杂度： 一个算法执行所耗费的时间。
    空间复杂度：运行完一个程序所需内存的大小。

时间复杂度


 <img src="img\数据结构与算法\20190903082730350.png" alt="20190903082730350" style="zoom: 50%;" />



### 1、交换排序

#### 1.1、冒泡排序
冒泡排序是一种简单的排序算法。
它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 
采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！

算法描述

    比较相邻的元素。如果第一个比第二个大，就交换它们两个；
    对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素就是最大的数；
    针对所有的元素重复以上的步骤，除了最后一个；
    重复步骤1~3，直到排序完成。


静态图演示：
 <img src="img\数据结构与算法\2_1_1_1.png" alt="20190903082730350" style="zoom:80%;" />

动态图演示：
 <img src="img\数据结构与算法\2_1_1_2.gif" alt="20190903082730350"  />

冒泡排序算法分析

    最佳情况：T(n) = O(n) 
    最差情况：T(n) = O(n2) 
    平均情况：T(n) = O(n2)


#### 1.2、快速排序
快速排序(Quick Sort)使用分治法策略。

它的基本思想是：

    在数据序列中选择一个元素作为基准值，每躺从数据序列的两端开始交替进行，将小于基准值元素交换到序列前端，将大于基准值的元素交换到序列后端，介于两者之间的位置则成为基准值的最终位置。
    同时，序列被划分成两个子序列，再分别对两个子序列进行快速排序，直到子序列长度为1，则完成排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

静态图展示:
 <img src="img\数据结构与算法\2_1_2_1.jpg" alt="20190903082730350" style="zoom:80%;" />
动态图演示:
 <img src="img\数据结构与算法\2_1_2_2.gif" alt="20190903082730350"  />

快速排序算法分析

    最佳情况：T(n) = O(nlogn) 
    最差情况：T(n) = O(n2) 
    平均情况：T(n) = O(nlog2n)　

### 2、插入排序

#### 2.1、插入排序（Insertion Sort）
直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成是一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。

算法描述

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

    1、从第一个元素开始，该元素可以认为已经被排序；
    2、取出下一个元素，在已经排序的元素序列中从后向前扫描；
    3、如果该元素（已排序）大于新元素，将该元素移到下一位置；
    4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
    5、将新元素插入到该位置后；
    重复步骤2~5。

静态图演示：
 <img src="img\数据结构与算法\2_2_1_1.png" alt="20190903082730350" style="zoom:80%;" />
动态图演示：
 <img src="img\数据结构与算法\2_2_1_2.gif" alt="20190903082730350" style="zoom:80%;" />

插入排序算法分析

    最佳情况：T(n) = O(n) 
    最坏情况：T(n) = O(n2) 
    平均情况：T(n) = O(n2)

#### 2.2、希尔排序（Shell Sort）
1959年Shell发明，第一个突破O(n^2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔(Shell)排序又称为缩小增量排序，该方法因DL.Shell于1959年提出而得名。

希尔排序的基本思想是：

    把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。
    随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。

静态图演示：
 <img src="img\数据结构与算法\2_2_2_1.png" alt="20190903082730350" style="zoom: 50%;" />
静态图解析：

    初始时，有一个大小为 10 的无序序列。
    在第一趟排序中，我们不妨设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。
    在第二趟排序中，我们把上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。按照直接插入排序的方法对每个组进行排序。
    在第三趟排序中，再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。
    需要注意一下的是，图中有两个相等数值的元素 5 和 5 。我们可以清楚的看到，在排序过程中，两个元素位置交换了。
    所以，希尔排序是不稳定的算法。
动态图演示：
 <img src="img\数据结构与算法\2_2_2_2.gif" alt="20190903082730350" style="zoom:80%;" />

希尔排序算法分析

    最佳情况：T(n) = O(nlog2n) 
    最坏情况：T(n) = O(nlog2n) 
    平均情况：T(n) =O(nlog2n)　

### 3、选择排序
    直接选择排序算法有两个缺点：选择最小值效率低，必须遍历子序列，比较了所有元素后才能选出最小值，每躺将最小值交换到前面，其余元素原地不动，下一趟没有利用前一躺的比较结果，需要再次比较这些元素，重复比较很多。
    堆排序改进了直接选择排序，采用最小/最大堆选择最小/最大值

#### 3.1、选择排序
选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，
然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

算法描述

n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：

    初始状态：无序区为R[1…n]，有序区为空；
    第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
    n-1趟结束，数组有序化了。

动态图演示：
 <img src="img\数据结构与算法\2_3_3_1.gif" alt="20190903082730350" style="zoom:80%;" />

选择排序算法分析

    最佳情况：T(n) = O(n2) 
    最差情况：T(n) = O(n2) 
    平均情况：T(n) = O(n2)

#### 3.2、堆排序（Heap Sort）
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
最小/大堆用于求最小/大值，堆序列用于多次求极值的应用问题。

算法描述

将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

动态图演示
 <img src="img\数据结构与算法\2_3_3_2.gif" alt="20190903082730350" style="zoom:80%;" />
堆排序算法分析

    最佳情况：T(n) = O(nlog2n) 
    最差情况：T(n) = O(nlog2n) 
    平均情况：T(n) = O(nlog2n)




### 4、归并排序
#### 1、归并排序
归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

算法描述

    把长度为n的输入序列分成两个长度为n/2的子序列；
    对这两个子序列分别采用归并排序；
    将两个排序好的子序列合并成一个最终的排序序列。


静态图演示：
 <img src="img\数据结构与算法\2_4_1_1.png" alt="20190903082730350" style="zoom:80%;" />
可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。

合并相邻有序子序列

再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。
 <img src="img\数据结构与算法\2_4_1_2.png" alt="20190903082730350" style="zoom:80%;" />
 <img src="img\数据结构与算法\2_4_1_3.png" alt="20190903082730350" style="zoom:80%;" />

动态图演示：
 <img src="img\数据结构与算法\2_4_1_4.gif" alt="20190903082730350" style="zoom:80%;" />

归并排序算法分析

    最佳情况：T(n) = O(n) 
    最差情况：T(n) = O(nlog2n) 
    平均情况：T(n) = O(nlog2n)

### 5、线性时间非比较类排序
#### 1、计数排序（Counting Sort）
计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。

算法描述：

    找出待排序的数组中最大和最小的元素；
    统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
    对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
    反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

动图演示：
 <img src="img\数据结构与算法\2_5_1_1.gif" alt="20190903082730350" style="zoom:80%;" />

计数排序算法分析

    当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。
    由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。
    
    最佳情况：T(n) = O(n+k) 
    最差情况：T(n) = O(n+k) 
    平均情况：T(n) = O(n+k)




#### 2、桶排序（Bucket Sort）

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排。

算法描述：

    人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；
    遍历输入数据，并且把数据一个一个放到对应的桶里去；
    对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；
    从不是空的桶里把排好序的数据拼接起来。
注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。

 <img src="img\数据结构与算法\2_5_2_1.png" alt="20190903082730350" style="zoom:80%;" />

桶排序算法分析：

    桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。
    很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 
    
    最佳情况：T(n) = O(n+k) 
    最差情况：T(n) = O(n+k) 
    平均情况：T(n) = O(n2)



#### 3、基数排序（Radix Sort）

基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。

算法描述

取得数组中的最大数，并取得位数；
arr为原始数组，从最低位开始取每个位组成radix数组；
对radix进行计数排序（利用计数排序适用于小范围数的特点）；

动图演示：
 <img src="img\数据结构与算法\2_5_3_1.gif" alt="20190903082730350" style="zoom:80%;" />

基数排序算法分析

最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k)。基数排序有两种方法：MSD 从高位开始进行排序 LSD 从低位开始进行排序 。基数排序 vs 计数排序 vs 桶排序。这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

 基数排序：根据键值的每位数字来分配桶
 计数排序：每个桶只存储单一键值
 桶排序：每个桶存储一定范围的数值



## 二、递归与分治
递归
直接或间接调用自身的算法。

分治法
将规模为n的问题分为k个规模较小的子问题。子问题和原问题相同且相互独立。递归地解决子问题并将子问题的解合并为原问题的解。

一般而言，将问题分为大小相近的子问题是最有效率的。通常将问题一分为二。

从设计模式可以看出，分治法一般用递归实现。所以分治法的效率可以通过递归表达式进行分析。则有：
